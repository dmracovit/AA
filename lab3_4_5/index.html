<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Algorithm Visualization</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 0;
      background: #f5f5f5;
      color: #333;
    }

    .container {
      max-width: 1000px;
      margin: 0 auto;
      padding: 20px;
    }

    h1, h2, h3 {
      text-align: center;
      color: #2c3e50;
      margin-bottom: 20px;
    }

    h1 {
      font-size: 28px;
      border-bottom: 2px solid #3498db;
      padding-bottom: 10px;
      margin-bottom: 30px;
    }
    
    .algorithm-section {
      margin-bottom: 30px;
    }

    .algorithm-buttons, .graph-type-selection {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
      margin-bottom: 20px;
      padding: 15px;
      background-color: #fff;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }

    .algo-button, .graph-button {
      background-color: #3498db;
      color: white;
      border: none;
      padding: 10px 15px;
      border-radius: 5px;
      cursor: pointer;
      font-weight: 600;
      transition: background-color 0.3s;
    }

    .algo-button:hover, .graph-button:hover {
      background-color: #2980b9;
    }

    .algo-button.reset {
      background-color: #e74c3c;
    }

    .algo-button.reset:hover {
      background-color: #c0392b;
    }

    .algo-button.compare {
      background-color: #2ecc71;
    }

    .algo-button.compare:hover {
      background-color: #27ae60;
    }

    .graph-button.active {
      background-color: #16a085;
      box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
    }
    
    .algo-section {
      padding: 0 10px;
      margin: 0 5px;
      border-right: 1px solid #ddd;
    }
    
    .algo-section:last-child {
      border-right: none;
    }

    .canvas-container {
      margin-bottom: 20px;
      padding: 15px;
      background-color: #fff;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    canvas {
      margin: 10px 0;
      border: 1px solid #ddd;
      border-radius: 4px;
      background-color: white;
    }

    .algorithm-info {
      background-color: #ecf0f1;
      padding: 15px;
      border-radius: 8px;
      margin-top: 20px;
      border-left: 5px solid #3498db;
    }

    .controls-container {
      display: flex;
      justify-content: center;
      align-items: center;
      margin-bottom: 15px;
      gap: 15px;
    }

    .input-group {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .input-group label {
      font-weight: bold;
    }

    input[type="number"] {
      padding: 8px;
      border-radius: 4px;
      border: 1px solid #ddd;
    }

    .complexity-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
    }

    .complexity-table th, .complexity-table td {
      border: 1px solid #ddd;
      padding: 10px;
      text-align: center;
    }

    .complexity-table th {
      background-color: #3498db;
      color: white;
    }

    .complexity-table tr:nth-child(even) {
      background-color: #f2f2f2;
    }

    footer {
      text-align: center;
      padding: 20px;
      margin-top: 40px;
      border-top: 1px solid #ddd;
      color: #7f8c8d;
      font-size: 14px;
    }

    .graph-type-section {
      margin-bottom: 20px;
    }

    .graph-type-description {
      font-style: italic;
      text-align: center;
      margin-bottom: 10px;
    }

    @media (max-width: 768px) {
      .algorithm-buttons, .graph-type-selection {
        flex-direction: column;
      }
      
      canvas {
        max-width: 100%;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Algorithm Visualization</h1>

    <!-- Graph Type Selection Section -->
    <div class="graph-type-section">
      <h2>Select Graph Type</h2>
      <p class="graph-type-description">Choose a graph structure to visualize how algorithms behave differently</p>
      
      <div class="controls-container">
        <div class="input-group">
          <label for="nodeCount">Number of Nodes:</label>
          <input type="number" id="nodeCount" min="5" max="50" value="12">
        </div>
      </div>
      
      <div class="graph-type-selection">
        <button class="graph-button active" onclick="selectGraphType('default')">Default</button>
        <button class="graph-button" onclick="selectGraphType('path')">Path</button>
        <button class="graph-button" onclick="selectGraphType('cycle')">Cycle</button>
        <button class="graph-button" onclick="selectGraphType('complete')">Complete</button>
        <button class="graph-button" onclick="selectGraphType('star')">Star</button>
        <button class="graph-button" onclick="selectGraphType('bipartite')">Bipartite</button>
        <button class="graph-button" onclick="selectGraphType('binary_tree')">Binary Tree</button>
        <button class="graph-button" onclick="selectGraphType('grid')">Grid</button>
        <button class="graph-button" onclick="selectGraphType('sparse')">Sparse Random</button>
        <button class="graph-button" onclick="selectGraphType('dense')">Dense Random</button>
      </div>
    </div>
    
    <div class="algorithm-section">
      <h2>Select Algorithm</h2>
      <div class="algorithm-buttons">
        <!-- Graph Traversal Algorithms -->
        <div class="algo-section">
          <button class="algo-button" onclick="runDFS()">Run DFS</button>
          <button class="algo-button" onclick="runBFS()">Run BFS</button>
        </div>
        
        <!-- Dynamic Programming Algorithms -->
        <div class="algo-section">
          <button class="algo-button" onclick="runDijkstra()">Run Dijkstra</button>
          <button class="algo-button" onclick="runFloydWarshall()">Run Floyd-Warshall</button>
        </div>
        
        <!-- Greedy Algorithms -->
        <div class="algo-section">
          <button class="algo-button" onclick="runPrim()">Run Prim</button>
          <button class="algo-button" onclick="runKruskal()">Run Kruskal</button>
        </div>
        
        <!-- Comparison and Utilities -->
        <div class="algo-section">
          <button class="algo-button reset" onclick="drawGraph()">Reset Graph</button>
          <button class="algo-button compare" onclick="measurePerformance()">Compare Performance</button>
        </div>
      </div>
      
      <div class="canvas-container">
        <canvas id="graphCanvas" width="800" height="600"></canvas>
      </div>
    </div>
    
    <!-- Performance Comparison Section -->
    <div class="canvas-container">
      <h3>Performance Comparison</h3>
      <canvas id="perfCanvas" width="800" height="300"></canvas>
      <button class="algo-button compare" onclick="drawComparison()">Show Theoretical Complexity</button>
      <h3>Theoretical Complexity</h3>
      <canvas id="theoryCanvas" width="800" height="300"></canvas>
    </div>
    
    <!-- Algorithm Information -->
    <div class="algorithm-info">
      <h3>Algorithm Overview</h3>
      
      <h4>Graph Traversal Algorithms</h4>
      <p><strong>Depth-First Search (DFS):</strong> Explores as far as possible along each branch before backtracking. It uses a stack data structure (or recursion) for its implementation.</p>
      <p><strong>Breadth-First Search (BFS):</strong> Explores all neighbors at the current depth before moving to nodes at the next depth level. It uses a queue data structure.</p>
      
      <h4>Dynamic Programming Algorithms</h4>
      <p><strong>Dijkstra's Algorithm:</strong> Finds the shortest paths from a single source to all other vertices in a weighted graph with non-negative edge weights. It uses dynamic programming by building solutions from previously found shortest paths.</p>
      <p><strong>Floyd-Warshall Algorithm:</strong> Finds shortest paths between all pairs of vertices in a weighted graph. It uses dynamic programming by considering all possible intermediate vertices for each pair.</p>
      
      <h4>Greedy Algorithms</h4>
      <p><strong>Prim's Algorithm:</strong> Finds the Minimum Spanning Tree (MST) by always adding the edge with the lowest weight that connects a vertex in the tree to a vertex outside the tree.</p>
      <p><strong>Kruskal's Algorithm:</strong> Finds the MST by considering edges in order of increasing weight, adding each edge that doesn't create a cycle.</p>

      <h4>Graph Types</h4>
      <p><strong>Path:</strong> A linear graph where nodes are connected in sequence.</p>
      <p><strong>Cycle:</strong> A graph where nodes form a circular path.</p>
      <p><strong>Complete:</strong> Every node is connected to every other node.</p>
      <p><strong>Star:</strong> One central node connected to all others.</p>
      <p><strong>Bipartite:</strong> Nodes can be divided into two distinct groups with edges only between groups.</p>
      <p><strong>Binary Tree:</strong> A hierarchical structure where each node has at most two children.</p>
      <p><strong>Grid:</strong> Nodes arranged in a 2D grid pattern.</p>
      <p><strong>Sparse Random:</strong> Randomly connected graph with few edges.</p>
      <p><strong>Dense Random:</strong> Randomly connected graph with many edges.</p>
      
      <h3>Time and Space Complexity</h3>
      <table class="complexity-table">
        <tr>
          <th>Algorithm</th>
          <th>Time Complexity</th>
          <th>Space Complexity</th>
          <th>Category</th>
          <th>Use Case</th>
        </tr>
        <tr>
          <td>DFS</td>
          <td>O(V + E)</td>
          <td>O(V)</td>
          <td>Graph Traversal</td>
          <td>Path finding, cycle detection</td>
        </tr>
        <tr>
          <td>BFS</td>
          <td>O(V + E)</td>
          <td>O(V)</td>
          <td>Graph Traversal</td>
          <td>Shortest path (unweighted)</td>
        </tr>
        <tr>
          <td>Dijkstra</td>
          <td>O(E log V)</td>
          <td>O(V)</td>
          <td>Dynamic Programming</td>
          <td>Single-source shortest paths</td>
        </tr>
        <tr>
          <td>Floyd-Warshall</td>
          <td>O(V³)</td>
          <td>O(V²)</td>
          <td>Dynamic Programming</td>
          <td>All-pairs shortest paths</td>
        </tr>
        <tr>
          <td>Prim</td>
          <td>O(E log V)</td>
          <td>O(V)</td>
          <td>Greedy</td>
          <td>Minimum spanning tree</td>
        </tr>
        <tr>
          <td>Kruskal</td>
          <td>O(E log E)</td>
          <td>O(V + E)</td>
          <td>Greedy</td>
          <td>Minimum spanning tree</td>
        </tr>
      </table>
    </div>
    
    <footer>
      Created for Algorithm Analysis Laboratory Work<br>
      Visualization helps understand graph algorithms through interactive demonstrations
    </footer>
  </div>

  <script>
    // Global definitions for nodes and edges
    const canvas = document.getElementById('graphCanvas');
    const ctx = canvas.getContext('2d');

    const perfCanvas = document.getElementById('perfCanvas');
    const perfCtx = perfCanvas.getContext('2d');

    const theoryCanvas = document.getElementById('theoryCanvas');
    const theoryCtx = theoryCanvas.getContext('2d');

    // Current graph type
    let currentGraphType = 'default';
    let nodes = [];
    let edges = [];
    let graph = {};
    
    // Initial graph generation
    generateGraph('default');

    /*---------------------------
      Graph Generation Functions
    ----------------------------*/
    function generateGraph(graphType) {
      const nodeCountInput = document.getElementById('nodeCount');
      const numNodes = parseInt(nodeCountInput.value) || 12;
      
      // Update UI
      currentGraphType = graphType;
      updateGraphTypeButtons();
      
      // Clear existing graph
      nodes = [];
      edges = [];
      
      // Generate nodes and edges based on graph type
      switch(graphType) {
        case 'path':
          generatePathGraph(numNodes);
          break;
        case 'cycle':
          generateCycleGraph(numNodes);
          break;
        case 'complete':
          generateCompleteGraph(numNodes);
          break;
        case 'star':
          generateStarGraph(numNodes);
          break;
        case 'bipartite':
          generateBipartiteGraph(numNodes);
          break;
        case 'binary_tree':
          generateBinaryTreeGraph(numNodes);
          break;
        case 'grid':
          generateGridGraph(numNodes);
          break;
        case 'sparse':
          generateRandomGraph(numNodes, 0.2);
          break;
        case 'dense':
          generateRandomGraph(numNodes, 0.7);
          break;
        default:
          generateDefaultGraph(numNodes);
      }
      
      // Build adjacency list representation
      buildAdjacencyList();
      
      // Draw the graph
      drawGraph();
    }
    
    function updateGraphTypeButtons() {
      const buttons = document.querySelectorAll('.graph-button');
      buttons.forEach(button => {
        if (button.textContent.toLowerCase().includes(currentGraphType) || 
           (button.textContent === 'Default' && currentGraphType === 'default')) {
          button.classList.add('active');
        } else {
          button.classList.remove('active');
        }
      });
    }
    
    function selectGraphType(type) {
      generateGraph(type);
    }
    
    /*---------------------------
      Different Graph Type Generators
    ----------------------------*/
    function generateDefaultGraph(numNodes) {
      // Original implementation with circular layout
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const outerRadius = Math.min(canvas.width, canvas.height) * 0.35;
      const innerRadius = outerRadius * 0.6;
      
      // Create nodes
      // Outer circle nodes
      const outerNodes = Math.min(numNodes - 4, 8);
      for (let i = 0; i < outerNodes; i++) {
        const angle = (2 * Math.PI * i) / outerNodes;
        nodes.push({
          id: i,
          x: centerX + outerRadius * Math.cos(angle),
          y: centerY + outerRadius * Math.sin(angle)
        });
      }
      
      // Inner circle nodes
      const innerNodes = Math.min(numNodes - outerNodes, 4);
      for (let i = 0; i < innerNodes; i++) {
        const angle = (2 * Math.PI * i) / innerNodes + Math.PI / innerNodes;
        nodes.push({
          id: outerNodes + i,
          x: centerX + innerRadius * Math.cos(angle),
          y: centerY + innerRadius * Math.sin(angle)
        });
      }
      
      // Center node if we have space
      if (numNodes > outerNodes + innerNodes) {
        nodes.push({
          id: outerNodes + innerNodes,
          x: centerX,
          y: centerY
        });
      }
      
      // Add remaining nodes randomly if needed
      for (let i = nodes.length; i < numNodes; i++) {
        const angle = Math.random() * 2 * Math.PI;
        const radius = Math.random() * outerRadius * 0.8;
        nodes.push({
          id: i,
          x: centerX + radius * Math.cos(angle),
          y: centerY + radius * Math.sin(angle)
        });
      }
      
      // Create edges - outer circle
      for (let i = 0; i < outerNodes; i++) {
        const next = (i + 1) % outerNodes;
        edges.push({ 
          from: i, 
          to: next, 
          weight: Math.floor(Math.random() * 8) + 2 
        });
      }
      
      // Connect inner to outer
      for (let i = 0; i < innerNodes; i++) {
        const outerIndex = Math.floor(i * outerNodes / innerNodes);
        edges.push({ 
          from: outerNodes + i, 
          to: outerIndex, 
          weight: Math.floor(Math.random() * 8) + 2 
        });
      }
      
      // Connect center to inner if it exists
      if (numNodes > outerNodes + innerNodes) {
        for (let i = 0; i < innerNodes; i++) {
          edges.push({ 
            from: outerNodes + innerNodes, 
            to: outerNodes + i, 
            weight: Math.floor(Math.random() * 8) + 2 
          });
        }
      }
      
      // Add some random edges to make it more interesting
      for (let i = 0; i < Math.min(numNodes, 5); i++) {
        const from = Math.floor(Math.random() * nodes.length);
        let to = Math.floor(Math.random() * nodes.length);
        // Avoid self-loops and duplicates
        while (to === from || edges.some(e => (e.from === from && e.to === to) || (e.from === to && e.to === from))) {
          to = Math.floor(Math.random() * nodes.length);
        }
        edges.push({ 
          from, 
          to, 
          weight: Math.floor(Math.random() * 8) + 2 
        });
      }
    }
    
    function generatePathGraph(numNodes) {
      // Position nodes in a line
      const startX = canvas.width * 0.1;
      const endX = canvas.width * 0.9;
      const y = canvas.height / 2;
      const step = (endX - startX) / (numNodes - 1);
      
      // Create nodes
      for (let i = 0; i < numNodes; i++) {
        nodes.push({
          id: i,
          x: startX + i * step,
          y: y + (i % 2 === 0 ? -20 : 20) // Slight zigzag for visibility
        });
      }
      
      // Create edges (path)
      for (let i = 0; i < numNodes - 1; i++) {
        edges.push({
          from: i,
          to: i + 1,
          weight: Math.floor(Math.random() * 8) + 2
        });
      }
    }
    
    function generateCycleGraph(numNodes) {
      // Position nodes in a circle
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const radius = Math.min(canvas.width, canvas.height) * 0.4;
      
      // Create nodes
      for (let i = 0; i < numNodes; i++) {
        const angle = (2 * Math.PI * i) / numNodes;
        nodes.push({
          id: i,
          x: centerX + radius * Math.cos(angle),
          y: centerY + radius * Math.sin(angle)
        });
      }
      
      // Create edges (cycle)
      for (let i = 0; i < numNodes; i++) {
        edges.push({
          from: i,
          to: (i + 1) % numNodes,
          weight: Math.floor(Math.random() * 8) + 2
        });
      }
    }
    
    function generateCompleteGraph(numNodes) {
      // Position nodes in a circle for visibility
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const radius = Math.min(canvas.width, canvas.height) * 0.4;
      
      // Create nodes
      for (let i = 0; i < numNodes; i++) {
        const angle = (2 * Math.PI * i) / numNodes;
        nodes.push({
          id: i,
          x: centerX + radius * Math.cos(angle),
          y: centerY + radius * Math.sin(angle)
        });
      }
      
      // Create edges (complete graph - every node connects to every other node)
      for (let i = 0; i < numNodes; i++) {
        for (let j = i + 1; j < numNodes; j++) {
          edges.push({
            from: i,
            to: j,
            weight: Math.floor(Math.random() * 8) + 2
          });
        }
      }
    }
    
    function generateStarGraph(numNodes) {
      // One central node with all others around it
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const radius = Math.min(canvas.width, canvas.height) * 0.4;
      
      // Create center node
      nodes.push({
        id: 0,
        x: centerX,
        y: centerY
      });
      
      // Create outer nodes
      for (let i = 1; i < numNodes; i++) {
        const angle = (2 * Math.PI * (i - 1)) / (numNodes - 1);
        nodes.push({
          id: i,
          x: centerX + radius * Math.cos(angle),
          y: centerY + radius * Math.sin(angle)
        });
      }
      
      // Create edges (star - all nodes connect to center)
      for (let i = 1; i < numNodes; i++) {
        edges.push({
          from: 0,
          to: i,
          weight: Math.floor(Math.random() * 8) + 2
        });
      }
    }
    
    function generateBipartiteGraph(numNodes) {
      const centerX = canvas.width / 2;
      const leftX = canvas.width * 0.25;
      const rightX = canvas.width * 0.75;
      
      // Half on the left, half on the right
      const half = Math.floor(numNodes / 2);
      const leftCount = half;
      const rightCount = numNodes - half;
      
      // Left side nodes
      const leftStepY = (canvas.height * 0.8) / (leftCount - 1 || 1);
      for (let i = 0; i < leftCount; i++) {
        nodes.push({
          id: i,
          x: leftX,
          y: canvas.height * 0.1 + i * leftStepY
        });
      }
      
      // Right side nodes
      const rightStepY = (canvas.height * 0.8) / (rightCount - 1 || 1);
      for (let i = 0; i < rightCount; i++) {
        nodes.push({
          id: leftCount + i,
          x: rightX,
          y: canvas.height * 0.1 + i * rightStepY
        });
      }
      
      // Create edges (bipartite - only between left and right)
      // Each left node connects to some right nodes
      for (let i = 0; i < leftCount; i++) {
        // Connect to at least one right node
        const connectionsCount = Math.floor(Math.random() * (rightCount - 1)) + 1;
        const connectedRight = new Set();
        
        for (let c = 0; c < connectionsCount; c++) {
          let rightNode;
          do {
            rightNode = leftCount + Math.floor(Math.random() * rightCount);
          } while (connectedRight.has(rightNode));
          
          connectedRight.add(rightNode);
          edges.push({
            from: i,
            to: rightNode,
            weight: Math.floor(Math.random() * 8) + 2
          });
        }
      }
    }
    
    function generateBinaryTreeGraph(numNodes) {
      // Calculate tree depth based on node count
      const depth = Math.floor(Math.log2(numNodes));
      const centerX = canvas.width / 2;
      const topY = canvas.height * 0.1;
      const verticalSpace = canvas.height * 0.8;
      
      // Create nodes level by level
      let nodeId = 0;
      for (let level = 0; level <= depth && nodeId < numNodes; level++) {
        const levelWidth = Math.pow(2, level);
        const horizontalStep = canvas.width / (levelWidth + 1);
        const levelY = topY + (level / depth) * verticalSpace;
        
        for (let i = 0; i < levelWidth && nodeId < numNodes; i++) {
          nodes.push({
            id: nodeId,
            x: (i + 1) * horizontalStep,
            y: levelY
          });
          
          // Connect to parent (except for root)
          if (nodeId > 0) {
            const parentId = Math.floor((nodeId - 1) / 2);
            edges.push({
              from: parentId,
              to: nodeId,
              weight: Math.floor(Math.random() * 8) + 2
            });
          }
          
          nodeId++;
        }
      }
    }
    
    function generateGridGraph(numNodes) {
      // Calculate approximate grid dimensions
      const gridSize = Math.ceil(Math.sqrt(numNodes));
      const cellWidth = canvas.width * 0.8 / gridSize;
      const cellHeight = canvas.height * 0.8 / gridSize;
      const startX = canvas.width * 0.1;
      const startY = canvas.height * 0.1;
      
      // Create nodes in a grid pattern
      let nodeId = 0;
      for (let row = 0; row < gridSize && nodeId < numNodes; row++) {
        for (let col = 0; col < gridSize && nodeId < numNodes; col++) {
          nodes.push({
            id: nodeId,
            x: startX + col * cellWidth,
            y: startY + row * cellHeight
          });
          nodeId++;
        }
      }
      
      // Create edges (connect to adjacent nodes)
      for (let row = 0; row < gridSize; row++) {
        for (let col = 0; col < gridSize; col++) {
          const currentId = row * gridSize + col;
          
          // Skip if this node doesn't exist
          if (currentId >= numNodes) continue;
          
          // Connect to right neighbor if it exists
          if (col + 1 < gridSize && currentId + 1 < numNodes) {
            edges.push({
              from: currentId,
              to: currentId + 1,
              weight: Math.floor(Math.random() * 8) + 2
            });
          }
          
          // Connect to bottom neighbor if it exists
          if (row + 1 < gridSize && currentId + gridSize < numNodes) {
            edges.push({
              from: currentId,
              to: currentId + gridSize,
              weight: Math.floor(Math.random() * 8) + 2
            });
          }
        }
      }
    }
    
    function generateRandomGraph(numNodes, density) {
      // Position nodes in a circle for visibility
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const radius = Math.min(canvas.width, canvas.height) * 0.4;
      
      // Create nodes
      for (let i = 0; i < numNodes; i++) {
        const angle = (2 * Math.PI * i) / numNodes;
        const r = radius * (0.8 + Math.random() * 0.2); // Some variation in radius
        nodes.push({
          id: i,
          x: centerX + r * Math.cos(angle),
          y: centerY + r * Math.sin(angle)
        });
      }
      
      // Create random edges based on density
      for (let i = 0; i < numNodes; i++) {
        for (let j = i + 1; j < numNodes; j++) {
          if (Math.random() < density) {
            edges.push({
              from: i,
              to: j,
              weight: Math.floor(Math.random() * 8) + 2
            });
          }
        }
      }
      
      // Ensure graph is connected by adding minimum spanning tree
      if (edges.length < numNodes - 1) {
        // Start with node 0
        const connectedNodes = new Set([0]);
        
        // Keep adding edges until all nodes are connected
        while (connectedNodes.size < numNodes) {
          // Find an edge that connects a connected node to an unconnected one
          let bestEdge = null;
          
          for (let i of connectedNodes) {
            for (let j = 0; j < numNodes; j++) {
              if (!connectedNodes.has(j)) {
                // This would be a valid edge to add
                if (!bestEdge || Math.random() < 0.5) {
                  bestEdge = { from: i, to: j, weight: Math.floor(Math.random() * 8) + 2 };
                }
              }
            }
          }
          
          if (bestEdge) {
            edges.push(bestEdge);
            connectedNodes.add(bestEdge.to);
          } else {
            // Shouldn't happen, but just in case
            break;
          }
        }
      }
    }
    
    function buildAdjacencyList() {
      // Create adjacency list representation for algorithms
      graph = {};
      nodes.forEach(node => graph[node.id] = []);
      edges.forEach(edge => {
        graph[edge.from].push(edge.to);
        graph[edge.to].push(edge.from); // Undirected graph
      });
    }

    // Utility delay function
    function delay(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    /*---------------------------
      Draw Base Graph Function
    ----------------------------*/
    function drawGraph(highlightedNodes = [], highlightedEdges = []) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw edges
      edges.forEach(edge => {
        ctx.beginPath();
        ctx.moveTo(nodes[edge.from].x, nodes[edge.from].y);
        ctx.lineTo(nodes[edge.to].x, nodes[edge.to].y);
        if (highlightedEdges.find(e => 
              (e.from === edge.from && e.to === edge.to) ||
              (e.from === edge.to && e.to === edge.from)
            )) {
          ctx.strokeStyle = '#f00';
          ctx.lineWidth = 4;
        } else {
          ctx.strokeStyle = '#000';
          ctx.lineWidth = 2;
        }
        ctx.stroke();
        
        // Add weight labels to edges
        const midX = (nodes[edge.from].x + nodes[edge.to].x) / 2;
        const midY = (nodes[edge.from].y + nodes[edge.to].y) / 2;
        
        // Add a small white background for better visibility
        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
        ctx.beginPath();
        ctx.arc(midX, midY, 10, 0, 2 * Math.PI);
        ctx.fill();
        
        ctx.fillStyle = '#555';
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(edge.weight, midX, midY);
      });

      // Draw nodes
      nodes.forEach(node => {
        ctx.beginPath();
        ctx.arc(node.x, node.y, 20, 0, Math.PI * 2);
        ctx.fillStyle = highlightedNodes.includes(node.id) ? '#0f0' : '#ccc';
        ctx.fill();
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        ctx.stroke();
        // Node ID
        ctx.fillStyle = '#000';
        ctx.font = '16px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(node.id, node.x, node.y);
      });
      
      // Add graph type info
      ctx.fillStyle = '#000';
      ctx.font = '20px Arial';
      ctx.textAlign = 'center';
      ctx.fillText(getGraphTypeDisplayName() + ' Graph Visualization', canvas.width / 2, 30);
    }
    
    function getGraphTypeDisplayName() {
      switch(currentGraphType) {
        case 'path': return 'Path';
        case 'cycle': return 'Cycle';
        case 'complete': return 'Complete';
        case 'star': return 'Star';
        case 'bipartite': return 'Bipartite';
        case 'binary_tree': return 'Binary Tree';
        case 'grid': return 'Grid';
        case 'sparse': return 'Sparse Random';
        case 'dense': return 'Dense Random';
        default: return 'Default';
      }
    }

    /*---------------------------
      DFS Implementation Demo
    ----------------------------*/
    async function runDFS() {
      drawGraph();
      await delay(500);
      const visited = {};
      const order = [];

      async function dfs(node) {
        visited[node] = true;
        order.push(node);
        drawGraph(order);
        await delay(500);
        for (let neighbor of graph[node]) {
          if (!visited[neighbor]) {
            await dfs(neighbor);
          }
        }
      }

      await dfs(0);
      
      // Add a completion message
      ctx.fillStyle = "#000";
      ctx.font = "24px Arial";
      ctx.textAlign = "center";
      ctx.fillText("DFS Traversal Complete: " + order.join(" → "), canvas.width / 2, canvas.height - 30);
    }

    /*---------------------------
      BFS Implementation Demo
    ----------------------------*/
    async function runBFS() {
      drawGraph();
      await delay(500);
      const visited = {};
      const order = [];
      const queue = [0];
      visited[0] = true;

      while (queue.length) {
        const node = queue.shift();
        order.push(node);
        drawGraph(order);
        await delay(500);
        for (let neighbor of graph[node]) {
          if (!visited[neighbor]) {
            visited[neighbor] = true;
            queue.push(neighbor);
          }
        }
      }
      
      // Add a completion message
      ctx.fillStyle = "#000";
      ctx.font = "24px Arial";
      ctx.textAlign = "center";
      ctx.fillText("BFS Traversal Complete: " + order.join(" → "), canvas.width / 2, canvas.height - 30);
    }

    /*---------------------------
      Prim's Algorithm Demo
    ----------------------------*/
    async function runPrim() {
      drawGraph();
      await delay(500);
      let mstNodes = new Set();
      let mstEdges = [];
      mstNodes.add(0);
      
      // Display the starting node
      ctx.fillStyle = "#000";
      ctx.font = "18px Arial";
      ctx.textAlign = "center";
      ctx.fillText("Starting from node 0", canvas.width / 2, 60);

      function getCandidateEdges() {
        return edges.filter(edge => 
          (mstNodes.has(edge.from) && !mstNodes.has(edge.to)) ||
          (mstNodes.has(edge.to) && !mstNodes.has(edge.from))
        );
      }

      while (mstNodes.size < nodes.length) {
        let candidateEdges = getCandidateEdges();
        if (candidateEdges.length === 0) break;
        candidateEdges.sort((a, b) => a.weight - b.weight);
        let chosenEdge = candidateEdges[0];
        
        // Highlight the chosen edge
        ctx.fillStyle = "#000";
        ctx.font = "16px Arial";
        ctx.textAlign = "center";
        ctx.fillText("Selected edge: " + chosenEdge.from + " → " + chosenEdge.to + " (weight: " + chosenEdge.weight + ")", canvas.width / 2, 90);
        
        mstEdges.push(chosenEdge);
        let newVertex = mstNodes.has(chosenEdge.from) ? chosenEdge.to : chosenEdge.from;
        mstNodes.add(newVertex);
        drawGraph(Array.from(mstNodes), mstEdges);
        await delay(800); // Slightly longer delay to see the steps better
      }
      
      // Calculate total MST weight
      const totalWeight = mstEdges.reduce((sum, edge) => sum + edge.weight, 0);

      ctx.fillStyle = "#000";
      ctx.font = "24px Arial";
      ctx.textAlign = "center";
      ctx.fillText("Prim's Algorithm: MST Complete", canvas.width / 2, canvas.height - 60);
      ctx.font = "18px Arial";
      ctx.fillText("Total MST Weight: " + totalWeight, canvas.width / 2, canvas.height - 30);
    }

    /*---------------------------
      Kruskal's Algorithm Demo
    ----------------------------*/
    async function runKruskal() {
      drawGraph();
      await delay(500);
      let sortedEdges = [...edges].sort((a, b) => a.weight - b.weight);
      let mstEdges = [];
      let parent = Array.from({ length: nodes.length }, (_, i) => i);
      
      // Display initial message
      ctx.fillStyle = "#000";
      ctx.font = "18px Arial";
      ctx.textAlign = "center";
      ctx.fillText("Sorting edges by weight", canvas.width / 2, 60);

      function find(x) {
        if (parent[x] !== x) {
          parent[x] = find(parent[x]);
        }
        return parent[x];
      }

      function union(x, y) {
        let rootX = find(x);
        let rootY = find(y);
        if (rootX === rootY) return false;
        parent[rootY] = rootX;
        return true;
      }

      for (let edge of sortedEdges) {
        drawGraph([], mstEdges);
        
        // Display current edge being considered
        ctx.fillStyle = "#000";
        ctx.font = "16px Arial";
        ctx.textAlign = "center";
        ctx.fillText("Considering edge: " + edge.from + " → " + edge.to + " (weight: " + edge.weight + ")", canvas.width / 2, 90);
        
        await delay(600);
        if (union(edge.from, edge.to)) {
          mstEdges.push(edge);
          drawGraph([], mstEdges);
          
          // Display edge being added
          ctx.fillStyle = "#000";
          ctx.font = "16px Arial";
          ctx.textAlign = "center";
          ctx.fillText("Added to MST: " + edge.from + " → " + edge.to, canvas.width / 2, 90);
          
          await delay(800);
        } else {
          drawGraph([], mstEdges);
          
          // Display edge creating cycle
          ctx.fillStyle = "#000";
          ctx.font = "16px Arial";
          ctx.textAlign = "center";
          ctx.fillText("Rejected (would create cycle): " + edge.from + " → " + edge.to, canvas.width / 2, 90);
          
          ctx.beginPath();
          ctx.setLineDash([5, 5]);
          ctx.moveTo(nodes[edge.from].x, nodes[edge.from].y);
          ctx.lineTo(nodes[edge.to].x, nodes[edge.to].y);
          ctx.strokeStyle = "#f00";
          ctx.lineWidth = 4;
          ctx.stroke();
          ctx.setLineDash([]);
          await delay(800);
          drawGraph([], mstEdges);
        }
      }
      
      // Calculate total MST weight
      const totalWeight = mstEdges.reduce((sum, edge) => sum + edge.weight, 0);

      ctx.fillStyle = "#000";
      ctx.font = "24px Arial";
      ctx.textAlign = "center";
      ctx.fillText("Kruskal's Algorithm: MST Complete", canvas.width / 2, canvas.height - 60);
      ctx.font = "18px Arial";
      ctx.fillText("Total MST Weight: " + totalWeight, canvas.width / 2, canvas.height - 30);
    }

    /*---------------------------
      Dijkstra's Algorithm Demo
    ----------------------------*/
    async function runDijkstra() {
      const weightedGraph = {};
      nodes.forEach(node => {
        weightedGraph[node.id] = [];
      });
      edges.forEach(edge => {
        weightedGraph[edge.from].push({ node: edge.to, weight: edge.weight });
        weightedGraph[edge.to].push({ node: edge.from, weight: edge.weight });
      });

      const distances = Array(nodes.length).fill(Infinity);
      const previous = Array(nodes.length).fill(null);
      const visited = new Set();
      distances[0] = 0;
      
      ctx.fillStyle = "#000";
      ctx.font = "18px Arial";
      ctx.textAlign = "center";
      ctx.fillText("Starting from node 0", canvas.width / 2, 60);

      function updateVisualization(current = null) {
        drawGraph(Array.from(visited));
        
        nodes.forEach(node => {
          ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
          ctx.beginPath();
          ctx.arc(node.x, node.y - 25, 15, 0, 2 * Math.PI);
          ctx.fill();
          
          ctx.fillStyle = "#000";
          ctx.font = "14px Arial";
          ctx.textAlign = "center";
          const d = distances[node.id] === Infinity ? "∞" : distances[node.id];
          ctx.fillText(d, node.x, node.y - 25);
          
          // Highlight the current node being processed
          if (node.id === current) {
            ctx.beginPath();
            ctx.arc(node.x, node.y, 25, 0, 2 * Math.PI);
            ctx.strokeStyle = "#00f";
            ctx.lineWidth = 3;
            ctx.stroke();
          }
        });
      }

      updateVisualization();
      await delay(800);

      while (visited.size < nodes.length) {
        let currentNode = null;
        let currentDist = Infinity;
        
        // Find the node with the smallest distance
        for (let i = 0; i < distances.length; i++) {
          if (!visited.has(i) && distances[i] < currentDist) {
            currentDist = distances[i];
            currentNode = i;
          }
        }
        
        // If we can't find a node, we're done
        if (currentNode === null) break;
        
        // Mark the node as visited
        visited.add(currentNode);
        
        // Display current node being processed
        ctx.fillStyle = "#000";
        ctx.font = "16px Arial";
        ctx.textAlign = "center";
        ctx.fillText("Processing node: " + currentNode + " (distance: " + distances[currentNode] + ")", canvas.width / 2, 90);
        
        updateVisualization(currentNode);
        await delay(800);
        
        // Check all neighbors
        for (let neighbor of weightedGraph[currentNode]) {
          if (!visited.has(neighbor.node)) {
            const newDist = distances[currentNode] + neighbor.weight;
            
            // If we found a shorter path
            if (newDist < distances[neighbor.node]) {
              // Display edge relaxation
              ctx.fillStyle = "#000";
              ctx.font = "16px Arial";
              ctx.textAlign = "center";
              ctx.fillText("Updating: " + currentNode + " → " + neighbor.node + " (new distance: " + newDist + ")", canvas.width / 2, 120);
              
              distances[neighbor.node] = newDist;
              previous[neighbor.node] = currentNode;
              updateVisualization(currentNode);
              await delay(800);
            }
          }
        }
        
        updateVisualization();
        await delay(600);
      }

      // Draw shortest path tree
      drawGraph(Array.from(visited));
      
      // Draw the final shortest paths
      for (let i = 1; i < nodes.length; i++) {
        if (previous[i] !== null) {
          ctx.beginPath();
          ctx.moveTo(nodes[previous[i]].x, nodes[previous[i]].y);
          ctx.lineTo(nodes[i].x, nodes[i].y);
          ctx.strokeStyle = "#00f";
          ctx.lineWidth = 3;
          ctx.stroke();
        }
      }
      
      // Draw the final distances
      nodes.forEach(node => {
        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
        ctx.beginPath();
        ctx.arc(node.x, node.y - 25, 15, 0, 2 * Math.PI);
        ctx.fill();
        
        ctx.fillStyle = "#000";
        ctx.font = "14px Arial";
        ctx.textAlign = "center";
        const d = distances[node.id] === Infinity ? "∞" : distances[node.id];
        ctx.fillText(d, node.x, node.y - 25);
      });
      
      ctx.fillStyle = "#000";
      ctx.font = "24px Arial";
      ctx.textAlign = "center";
      ctx.fillText("Dijkstra's Algorithm: Shortest Paths Computed", canvas.width / 2, canvas.height - 30);
    }

    /*---------------------------
      Floyd–Warshall Algorithm Demo
    ----------------------------*/
    async function runFloydWarshall() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "#000";
      ctx.font = "24px Arial";
      ctx.textAlign = "center";
      ctx.fillText("Floyd–Warshall Algorithm Demo", canvas.width / 2, 30);
      await delay(800);

      const n = nodes.length;
      let dist = Array.from({ length: n }, () => Array(n).fill(Infinity));
      
      for (let i = 0; i < n; i++) {
        dist[i][i] = 0; // Distance to self is 0
      }
      
      for (let e of edges) {
        dist[e.from][e.to] = e.weight;
        dist[e.to][e.from] = e.weight; // For undirected graph
      }
      
      ctx.fillStyle = "#000";
      ctx.font = "18px Arial";
      ctx.textAlign = "center";
      ctx.fillText("Initial Distance Matrix", canvas.width / 2, 60);
      
      drawFloydWarshallGraph(dist, [], "Initial Graph");
      await delay(1200);
      
      for (let k = 0; k < n; k++) {
        let changedEdges = [];
        
        ctx.fillStyle = "#000";
        ctx.font = "18px Arial";
        ctx.textAlign = "center";
        ctx.fillText(`Using node ${k} as intermediate`, canvas.width / 2, 60);
        
        // Check all pairs of vertices
        for (let i = 0; i < n; i++) {
          for (let j = 0; j < n; j++) {
            // Skip if i = j (self-loops)
            if (i === j) continue;
            
            // Calculate potential new distance through k
            let throughK = dist[i][k] + dist[k][j];
            
            // If going through k is shorter
            if (throughK < dist[i][j]) {
              // Display the improvement
              ctx.fillStyle = "#000";
              ctx.font = "16px Arial";
              ctx.textAlign = "center";
              ctx.fillText(`Improved: ${i} → ${j} via ${k} (${dist[i][j]} → ${throughK})`, canvas.width / 2, 90);
              
              // Update distance
              dist[i][j] = throughK;
              changedEdges.push({ i, j });
            }
          }
        }
        
        // Visualize the updated graph
        drawFloydWarshallGraph(dist, changedEdges, `After using node ${k}`);
        await delay(1200);
      }
      
      // Final visualization
      ctx.fillStyle = "#000";
      ctx.font = "24px Arial";
      ctx.textAlign = "center";
      ctx.fillText("Floyd–Warshall: All Pairs Shortest Paths Computed", canvas.width / 2, canvas.height - 30);
    }

    function drawFloydWarshallGraph(dist, changedEdges, title) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Draw nodes
      nodes.forEach(node => {
        ctx.beginPath();
        ctx.arc(node.x, node.y, 20, 0, 2 * Math.PI);
        ctx.fillStyle = "#ccc";
        ctx.fill();
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Node ID
        ctx.fillStyle = '#000';
        ctx.font = '16px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(node.id, node.x, node.y);
      });
      
      // Draw edges based on the distance matrix
      for (let i = 0; i < nodes.length; i++) {
        for (let j = i + 1; j < nodes.length; j++) {
          // Only draw edges that exist (finite distance)
          if (dist[i][j] !== Infinity) {
            // Check if the edge was changed in this iteration
            let isChanged = changedEdges.some(
              e => (e.i === i && e.j === j) || (e.i === j && e.j === i)
            );
            
            ctx.beginPath();
            ctx.moveTo(nodes[i].x, nodes[i].y);
            ctx.lineTo(nodes[j].x, nodes[j].y);
            ctx.strokeStyle = isChanged ? '#f00' : '#00f';
            ctx.lineWidth = isChanged ? 4 : 2;
            ctx.stroke();
            
            // Add weight labels
            const midX = (nodes[i].x + nodes[j].x) / 2;
            const midY = (nodes[i].y + nodes[j].y) / 2;
            
            // White background for better visibility
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.beginPath();
            ctx.arc(midX, midY, 12, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.fillStyle = isChanged ? '#f00' : '#000';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(dist[i][j], midX, midY);
          }
        }
      }
      
      // Add title
      ctx.fillStyle = "#000";
      ctx.font = "24px Arial";
      ctx.textAlign = "center";
      ctx.fillText(title, canvas.width / 2, 30);
    }

    /*---------------------------
      Performance Measurement & Chart
    ----------------------------*/
    async function measurePerformance() {
      const algorithms = [
        { name: 'DFS', func: runDFS },
        { name: 'BFS', func: runBFS },
        { name: 'Prim', func: runPrim },
        { name: 'Kruskal', func: runKruskal },
        { name: 'Dijkstra', func: runDijkstra },
        { name: 'Floyd–Warshall', func: runFloydWarshall }
      ];

      drawGraph();
      await delay(500);
      const results = [];

      for (let algo of algorithms) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#000";
        ctx.font = "24px Arial";
        ctx.textAlign = "center";
        ctx.fillText(`Running ${algo.name}...`, canvas.width / 2, canvas.height / 2);
        await delay(500);
        const start = performance.now();
        await algo.func();
        const end = performance.now();
        results.push({ name: algo.name, time: end - start });
        await delay(500);
      }
      drawPerformanceChart(results);
      
      // Update graph type info for comparison
      const graphTypeInfo = document.createElement('div');
      graphTypeInfo.textContent = `Performance measured on ${getGraphTypeDisplayName()} graph with ${nodes.length} nodes and ${edges.length} edges`;
      graphTypeInfo.style.textAlign = 'center';
      graphTypeInfo.style.marginTop = '10px';
      graphTypeInfo.style.fontStyle = 'italic';
      perfCanvas.parentNode.appendChild(graphTypeInfo);
    }

    function drawPerformanceChart(data) {
      perfCtx.clearRect(0, 0, perfCanvas.width, perfCanvas.height);
      const margin = 50;
      const chartWidth = perfCanvas.width - margin * 2;
      const chartHeight = perfCanvas.height - margin * 2;
      const maxTime = Math.max(...data.map(d => d.time));
      
      // Draw background for better visibility
      perfCtx.fillStyle = '#f9f9f9';
      perfCtx.fillRect(0, 0, perfCanvas.width, perfCanvas.height);
      
      // Draw axes
      perfCtx.beginPath();
      perfCtx.moveTo(margin, margin);
      perfCtx.lineTo(margin, margin + chartHeight);
      perfCtx.lineTo(margin + chartWidth, margin + chartHeight);
      perfCtx.strokeStyle = "#000";
      perfCtx.lineWidth = 2;
      perfCtx.stroke();
      
      // Draw y-axis grid lines and labels
      const numGridLines = 5;
      for (let i = 0; i <= numGridLines; i++) {
        const y = margin + chartHeight - (i / numGridLines) * chartHeight;
        const value = (i / numGridLines) * maxTime;
        
        // Draw grid line
        perfCtx.beginPath();
        perfCtx.moveTo(margin, y);
        perfCtx.lineTo(margin + chartWidth, y);
        perfCtx.strokeStyle = "#ccc";
        perfCtx.lineWidth = 1;
        perfCtx.stroke();
        
        // Draw label
        perfCtx.fillStyle = "#666";
        perfCtx.font = "12px Arial";
        perfCtx.textAlign = "right";
        perfCtx.textBaseline = "middle";
        perfCtx.fillText(value.toFixed(0) + " ms", margin - 5, y);
      }
      
      // Draw bars
      const barWidth = chartWidth / data.length - 20;
      const colors = ['#4285F4', '#EA4335', '#FBBC05', '#34A853', '#FF6D01', '#46BDC6'];
      
      data.forEach((d, i) => {
        const barHeight = (d.time / maxTime) * chartHeight;
        const x = margin + i * ((chartWidth) / data.length) + 10;
        const y = margin + chartHeight - barHeight;
        
        // Draw bar with gradient
        const gradient = perfCtx.createLinearGradient(x, y, x, y + barHeight);
        gradient.addColorStop(0, colors[i % colors.length]);
        gradient.addColorStop(1, lightenColor(colors[i % colors.length], 0.3));
        
        perfCtx.fillStyle = gradient;
        perfCtx.fillRect(x, y, barWidth, barHeight);
        
        // Add border
        perfCtx.strokeStyle = "#000";
        perfCtx.lineWidth = 1;
        perfCtx.strokeRect(x, y, barWidth, barHeight);
        
        // Add algorithm name
        perfCtx.fillStyle = "#000";
        perfCtx.font = "14px Arial";
        perfCtx.textAlign = "center";
        perfCtx.fillText(d.name, x + barWidth / 2, margin + chartHeight + 15);
        
        // Add time value
        perfCtx.fillStyle = "#000";
        perfCtx.font = "12px Arial";
        perfCtx.fillText(d.time.toFixed(0) + " ms", x + barWidth / 2, y - 5);
      });
      
      // Add title
      perfCtx.fillStyle = "#000";
      perfCtx.font = "20px Arial";
      perfCtx.textAlign = "center";
      perfCtx.fillText("Algorithm Execution Time Comparison", perfCanvas.width / 2, margin - 10);
      
      // Add subtitle with graph type
      perfCtx.fillStyle = "#333";
      perfCtx.font = "16px Arial";
      perfCtx.textAlign = "center";
      perfCtx.fillText(`Graph Type: ${getGraphTypeDisplayName()}`, perfCanvas.width / 2, margin + 15);
      
      // Add legend for what time includes
      perfCtx.fillStyle = "#666";
      perfCtx.font = "12px Arial";
      perfCtx.textAlign = "center";
      perfCtx.fillText("Note: Times include visualization delays", perfCanvas.width / 2, perfCanvas.height - 10);
    }

    // Helper function to lighten colors
    function lightenColor(color, factor) {
      // Convert hex to RGB
      let r, g, b;
      if (color.startsWith('#')) {
        r = parseInt(color.substr(1, 2), 16);
        g = parseInt(color.substr(3, 2), 16);
        b = parseInt(color.substr(5, 2), 16);
      } else {
        return color; // Not a hex color
      }
      
      // Lighten
      r = Math.min(255, r + (255 - r) * factor);
      g = Math.min(255, g + (255 - g) * factor);
      b = Math.min(255, b + (255 - b) * factor);
      
      // Convert back to hex
      return "#" + 
        Math.round(r).toString(16).padStart(2, '0') + 
        Math.round(g).toString(16).padStart(2, '0') + 
        Math.round(b).toString(16).padStart(2, '0');
    }

    function drawComparison() {
      theoryCtx.clearRect(0, 0, theoryCanvas.width, theoryCanvas.height);
      
      // Draw background
      theoryCtx.fillStyle = '#f9f9f9';
      theoryCtx.fillRect(0, 0, theoryCanvas.width, theoryCanvas.height);

      const V = nodes.length;
      const E = edges.length;

      // Adjust theoretical times based on graph structure
      function getComplexityFactor() {
        switch(currentGraphType) {
          case 'path': return 0.8;
          case 'cycle': return 0.8;
          case 'complete': return 1.5;
          case 'star': return 0.5;
          case 'bipartite': return 1.0;
          case 'binary_tree': return 0.9;
          case 'grid': return 1.2;
          case 'sparse': return 1.0;
          case 'dense': return 1.4;
          default: return 1.0;
        }
      }
      
      function randomFactor() {
        return 0.8 + Math.random() * 0.4;  
      }
     
      const baseTime = 1e-6;
      const complexityFactor = getComplexityFactor();
      
      const theory = [
        { name: "DFS", time: (V + E) * baseTime * randomFactor() * complexityFactor, complexity: "O(V + E)" },
        { name: "BFS", time: (V + E) * baseTime * randomFactor() * complexityFactor, complexity: "O(V + E)" },
        { name: "Prim", time: (E * Math.log2(V)) * baseTime * randomFactor() * complexityFactor, complexity: "O(E log V)" },
        { name: "Kruskal", time: (E * Math.log2(E)) * baseTime * randomFactor() * complexityFactor, complexity: "O(E log E)" },
        { name: "Dijkstra", time: (E * Math.log2(V)) * baseTime * randomFactor() * complexityFactor, complexity: "O(E log V)" },
        { name: "Floyd–Warshall", time: (V ** 3) * baseTime * randomFactor() * complexityFactor, complexity: "O(V³)" }
      ];

      const margin = 50;
      const chartWidth = theoryCanvas.width - margin * 2;
      const chartHeight = theoryCanvas.height - margin * 2;

      // Find max execution time for scaling
      const maxTime = Math.max(...theory.map(d => d.time));

      // Draw axes
      theoryCtx.beginPath();
      theoryCtx.moveTo(margin, margin);
      theoryCtx.lineTo(margin, margin + chartHeight);
      theoryCtx.lineTo(margin + chartWidth, margin + chartHeight);
      theoryCtx.strokeStyle = "#000";
      theoryCtx.lineWidth = 2;
      theoryCtx.stroke();
      
      // Draw y-axis grid lines and labels
      const numGridLines = 5;
      for (let i = 0; i <= numGridLines; i++) {
        const y = margin + chartHeight - (i / numGridLines) * chartHeight;
        const value = (i / numGridLines) * maxTime;
        
        // Draw grid line
        theoryCtx.beginPath();
        theoryCtx.moveTo(margin, y);
        theoryCtx.lineTo(margin + chartWidth, y);
        theoryCtx.strokeStyle = "#ccc";
        theoryCtx.lineWidth = 1;
        theoryCtx.stroke();
        
        // Draw label
        theoryCtx.fillStyle = "#666";
        theoryCtx.font = "12px Arial";
        theoryCtx.textAlign = "right";
        theoryCtx.textBaseline = "middle";
        theoryCtx.fillText(value.toFixed(6) + " s", margin - 5, y);
      }

      // Bar Chart
      const barWidth = chartWidth / theory.length - 20;
      const colors = ['#4285F4', '#EA4335', '#FBBC05', '#34A853', '#FF6D01', '#46BDC6'];
      
      theory.forEach((d, i) => {
        const barHeight = (d.time / maxTime) * chartHeight;
        const x = margin + i * ((chartWidth) / theory.length) + 10;
        const y = margin + chartHeight - barHeight;
        
        // Draw bar with gradient
        const gradient = theoryCtx.createLinearGradient(x, y, x, y + barHeight);
        gradient.addColorStop(0, colors[i % colors.length]);
        gradient.addColorStop(1, lightenColor(colors[i % colors.length], 0.3));
        
        theoryCtx.fillStyle = gradient;
        theoryCtx.fillRect(x, y, barWidth, barHeight);
        
        // Add border
        theoryCtx.strokeStyle = "#000";
        theoryCtx.lineWidth = 1;
        theoryCtx.strokeRect(x, y, barWidth, barHeight);
        
        // Add algorithm name
        theoryCtx.fillStyle = "#000";
        theoryCtx.font = "14px Arial";
        theoryCtx.textAlign = "center";
        theoryCtx.fillText(d.name, x + barWidth / 2, margin + chartHeight + 15);
        
        // Add complexity
        theoryCtx.fillStyle = "#333";
        theoryCtx.font = "12px Arial";
        theoryCtx.fillText(d.complexity, x + barWidth / 2, margin + chartHeight + 35);
        
        // Add time value
        theoryCtx.fillStyle = "#000";
        theoryCtx.font = "12px Arial";
        theoryCtx.fillText(d.time.toFixed(6) + " s", x + barWidth / 2, y - 5);
      });

      // Title
      theoryCtx.fillStyle = "#000";
      theoryCtx.font = "20px Arial";
      theoryCtx.textAlign = "center";
      theoryCtx.fillText("Theoretical Time Complexity Comparison", theoryCanvas.width / 2, margin - 10);
      
      // Add subtitle with graph type
      theoryCtx.fillStyle = "#333";
      theoryCtx.font = "16px Arial";
      theoryCtx.textAlign = "center";
      theoryCtx.fillText(`Graph Type: ${getGraphTypeDisplayName()} (V=${V}, E=${E})`, theoryCanvas.width / 2, margin + 15);
      
      // Add explanation
      theoryCtx.fillStyle = "#666";
      theoryCtx.font = "12px Arial";
      theoryCtx.textAlign = "center";
      theoryCtx.fillText("This chart shows relative theoretical performance based on algorithm complexity", 
                         theoryCanvas.width / 2, theoryCanvas.height - 10);
    }

  </script>
</body>
</html>